# mi_calculator.py
import torch
import numpy as np

# --- Step 1: Load tensors (from your preprocessing step) ---
data = torch.load("discretization/discretized_bankruptcy_kmeans.pt")
X = data["X"]   # discretized features (long tensor)
y = data["y"]   # target labels (long tensor)
feature_names = data["feature_names"]

n_samples, n_features = X.shape
n_classes = len(torch.unique(y))
n_bins = int(torch.max(X).item()) + 1  # number of bins per feature

print(f"Samples: {n_samples}, Features: {n_features}, Classes: {n_classes}, Bins: {n_bins}\n")


# --- Step 2: Generic mutual information function ---
def mutual_information(x, y, n_bins_x, n_bins_y):
    """
    Compute MI(x;y) for discrete variables x, y without external libraries
    """
    n = len(x)

    # Marginal distributions
    px = torch.bincount(x, minlength=n_bins_x).float() / n
    py = torch.bincount(y, minlength=n_bins_y).float() / n

    # Joint distribution
    joint_counts = torch.zeros((n_bins_x, n_bins_y))
    for xi, yi in zip(x, y):
        joint_counts[xi, yi] += 1
    pxy = joint_counts / n

    # MI computation
    mi = 0.0
    for i in range(n_bins_x):
        for j in range(n_bins_y):
            p_xy = pxy[i, j].item()
            if p_xy > 0:
                mi += p_xy * np.log2(p_xy / (px[i].item() * py[j].item()))
    return mi


# --- Step 3: Relevance (Feature vs Target) ---
relevance = np.zeros(n_features)
for f in range(n_features):
    relevance[f] = mutual_information(X[:, f], y, n_bins, n_classes)

# --- Step 4: Redundancy (Feature vs Feature) ---
redundancy = np.zeros((n_features, n_features))
for i in range(n_features):
    for j in range(n_features):
        redundancy[i, j] = mutual_information(X[:, i], X[:, j], n_bins, n_bins)

# --- Step 5: Round results ---
relevance_list = [round(val, 5) for val in relevance.tolist()]
redundancy_list = [[round(val, 10) for val in row] for row in redundancy.tolist()]

# --- Step 6: Save results to ml_result.py ---
with open("results\\manual_ml_result.py", "w") as f:
    f.write("# Auto-generated by mi_calculator.py\n\n")
    f.write(f"feature_names = {feature_names}\n\n")
    f.write(f"target_name = 'bankruptcy'\n\n")
    f.write(f"relevance = {relevance_list}\n\n")
    f.write(f"redundancy = {redundancy_list}\n")

print("\nâœ… Results written to results\\manual_ml_result.py (rounded to 5 decimals for relevance, 10 decimals for redundancy)")
